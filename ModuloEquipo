mport streamlit as st
import pandas as pd
from openpyxl import load_workbook
import json
from datetime import datetime
import pytz
from st_aggrid import AgGrid, GridOptionsBuilder, GridUpdateMode, DataReturnMode
import requests
from PIL import Image
from io import BytesIO
import os
import re

# ===============================
# Inicializaci√≥n del Estado de Sesi√≥n
# ===============================

# Inicializar el estado del pedido y el stock si no existen
if 'pedido' not in st.session_state:
    st.session_state.pedido = []

# Inicializar 'df_productos' si no existe
if 'df_productos' not in st.session_state:
    file_path_productos = 'archivo_modificado_productos_20240928_201237.xlsx'  # Archivo de productos
    if os.path.exists(file_path_productos):
        try:
            st.session_state.df_productos = pd.read_excel(file_path_productos)
        except Exception as e:
            st.error(f"Error al cargar el archivo de productos: {e}")
            st.stop()
    else:
        st.warning(f"‚ö†Ô∏è El archivo {file_path_productos} no existe. Por favor, s√∫belo desde el m√≥dulo Productos.")
        st.session_state.df_productos = pd.DataFrame()  # DataFrame vac√≠o

# Inicializar 'df_clientes' si no existe
if 'df_clientes' not in st.session_state:
    file_path_clientes = 'archivo_modificado_clientes_20240928_200050.xlsx'  # Archivo de clientes
    if os.path.exists(file_path_clientes):
        try:
            st.session_state.df_clientes = pd.read_excel(file_path_clientes)
        except Exception as e:
            st.error(f"Error al cargar el archivo de clientes: {e}")
            st.stop()
    else:
        st.warning(f"‚ö†Ô∏è El archivo {file_path_clientes} no existe. Por favor, s√∫belo desde el m√≥dulo Convertidor de CSV.")
        st.session_state.df_clientes = pd.DataFrame()  # DataFrame vac√≠o

# Inicializar 'delete_confirm' como un diccionario si no existe
if 'delete_confirm' not in st.session_state:
    st.session_state.delete_confirm = {}

# Inicializar 'df_equipo' si no existe
if 'df_equipo' not in st.session_state:
    file_path_equipo = 'equipo.xlsx'
    if os.path.exists(file_path_equipo):
        try:
            st.session_state.df_equipo = pd.read_excel(file_path_equipo)
        except Exception as e:
            st.error(f"Error al cargar el archivo de equipo: {e}")
            st.stop()
    else:
        # Definir los miembros del equipo
        data_equipo = {
            'Nombre': [
                'Joni', 'Eduardo', 'Johan', 'Martin',
                'Marian', 'Sofi', 'Valen', 'Emily',
                'Maria-Jose', 'Vasco'
            ],
            'Rol': [
                'Presidente', 'Gerente General', 'Jefe de Dep√≥sito', 'Armar Pedidos',
                'Vendedora', 'Vendedora', 'Vendedora', 'Vendedora',
                'Fot√≥grafa y Catalogador', 'Super Admin'
            ],
            'Departamento': [
                'Direcci√≥n', 'Direcci√≥n', 'Dep√≥sito', 'Dep√≥sito',
                'Ventas', 'Ventas', 'Ventas', 'Ventas',
                'Marketing', 'Direcci√≥n'
            ],
            'Nivel de Acceso': [
                'Alto', 'Alto', 'Medio', 'Medio',
                'Bajo', 'Bajo', 'Bajo', 'Bajo',
                'Medio', 'Super Admin'
            ]
        }
        st.session_state.df_equipo = pd.DataFrame(data_equipo)
        # Guardar el DataFrame inicial en Excel
        try:
            st.session_state.df_equipo.to_excel(file_path_equipo, index=False)
        except Exception as e:
            st.error(f"Error al guardar el archivo de equipo: {e}")

# Inicializar 'usuario' en sesi√≥n si no existe
if 'usuario' not in st.session_state:
    st.session_state.usuario = None

# ===============================
# Funciones Utilitarias
# ===============================

# Funci√≥n para convertir DataFrame a Excel en memoria usando openpyxl
def convertir_a_excel(df, sheet_name='Hoja1'):
    buffer = BytesIO()
    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name=sheet_name)
    excel_bytes = buffer.getvalue()
    return excel_bytes

# Funci√≥n para agregar el footer
def agregar_footer():
    footer = """
    <style>
    .footer {
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        background-color: #f1f1f1;
        color: #555;
        text-align: center;
        padding: 10px 0;
        font-size: 14px;
    }
    </style>
    <div class="footer">
        Powered by VASCO.SORO
    </div>
    """
    st.markdown(footer, unsafe_allow_html=True)

# Funci√≥n para asegurar que el valor es al menos el m√≠nimo permitido
def safe_value(value, min_value=0.0):
    try:
        return max(float(value), min_value)
    except:
        return min_value

# Funci√≥n para aplicar color al stock y mostrar el t√≠tulo, cantidad y detalle
def color_stock(stock):
    try:
        stock = int(stock)
    except:
        stock = 0
    if stock > 10:
        return f'üü¢ Stock\n**{stock} unidades**\n(Suficiente stock)'
    elif stock > 0:
        return f'üü° Stock\n**{stock} unidades**\n(Poco stock)'
    else:
        return f'üî¥ Stock\n**{stock} unidades**\n(Sin stock)'

# Funci√≥n para guardar el equipo en Excel
def guardar_equipo_excel(file_path):
    try:
        st.session_state.df_equipo.to_excel(file_path, index=False)
    except Exception as e:
        st.error(f"Error al guardar el archivo de equipo: {e}")

# Funci√≥n para guardar el pedido en Excel
def guardar_pedido_excel(file_path, order_data):
    try:
        book = load_workbook(file_path)
        if 'Pedidos' in book.sheetnames:
            sheet = book['Pedidos']
        else:
            sheet = book.create_sheet('Pedidos')
            # Escribir encabezados
            sheet.append(['ID Pedido', 'Cliente', 'Vendedor', 'Fecha', 'Hora', 'Items'])
        
        # Generar ID de pedido
        if sheet.max_row == 1:
            id_pedido = 1
        else:
            last_id = sheet['A'][sheet.max_row - 1].value
            id_pedido = last_id + 1 if last_id is not None else 1
        
        # Formatear los √≠tems como JSON
        items_json = json.dumps(order_data['items'], ensure_ascii=False)
        
        # Agregar nueva fila
        sheet.append([
            id_pedido,
            order_data['cliente'],
            order_data['vendedor'],
            order_data['fecha'],
            order_data['hora'],
            items_json
        ])
        
        # Guardar el libro
        book.save(file_path)
    except Exception as e:
        st.error(f"Error al guardar el pedido: {e}")

# ===============================
# Funciones de Autenticaci√≥n y Control de Acceso
# ===============================

def login():
    st.sidebar.title("üîí Iniciar Sesi√≥n")
    
    # Campo de texto para ingresar el nombre
    nombre_busqueda = st.sidebar.text_input(
        "Escribe tu nombre",
        placeholder="Comienza a escribir tu nombre...",
        key="nombre_busqueda"
    )
    
    # Filtrar los nombres que contienen la b√∫squeda (case insensitive)
    if nombre_busqueda:
        opciones_filtradas = st.session_state.df_equipo[
            st.session_state.df_equipo['Nombre'].str.contains(nombre_busqueda, case=False, na=False)
        ]['Nombre'].tolist()
    else:
        opciones_filtradas = st.session_state.df_equipo['Nombre'].tolist()
    
    # Agregar una opci√≥n vac√≠a al inicio
    opciones_filtradas = [""] + opciones_filtradas
    
    # Selectbox con las opciones filtradas
    nombre_seleccionado = st.sidebar.selectbox(
        "Selecciona tu nombre",
        opciones_filtradas,
        key="nombre_seleccionado",
        help="Selecciona tu nombre de la lista."
    )
    
    # Si se selecciona un nombre, autenticar al usuario
    if nombre_seleccionado:
        usuario_data = st.session_state.df_equipo[st.session_state.df_equipo['Nombre'] == nombre_seleccionado].iloc[0]
        st.session_state.usuario = {
            'Nombre': usuario_data['Nombre'],
            'Rol': usuario_data['Rol'],
            'Departamento': usuario_data['Departamento'],
            'Nivel de Acceso': usuario_data['Nivel de Acceso']
        }
        st.sidebar.success(f"Bienvenido, {usuario_data['Nombre']} ({usuario_data['Rol']})")
    else:
        st.sidebar.info("Por favor, escribe y selecciona tu nombre para iniciar sesi√≥n.")

def verificar_acceso(nivel_requerido):
    niveles = {
        'Bajo': 1,
        'Medio': 2,
        'Alto': 3,
        'Super Admin': 4
    }
    if st.session_state.usuario:
        usuario_nivel = st.session_state.usuario['Nivel de Acceso']
        if niveles.get(usuario_nivel, 0) >= niveles.get(nivel_requerido, 0):
            return True
    return False

# ===============================
# Funciones de M√≥dulos
# ===============================

def modulo_ventas():
    # Colocamos el buscador de cliente
    col1, col2 = st.columns([2, 1])
    
    with col1:
        cliente_seleccionado = st.selectbox(
            "üîÆ Buscar cliente", [""] + st.session_state.df_clientes['Nombre'].unique().tolist(),
            help="Escrib√≠ el nombre del cliente o seleccion√° uno de la lista."
        )
    
    # Solo mostramos los dem√°s campos si se selecciona un cliente distinto al espacio vac√≠o
    if cliente_seleccionado != "":
        cliente_data = st.session_state.df_clientes[st.session_state.df_clientes['Nombre'] == cliente_seleccionado].iloc[0]
    
        # Mostrar descuento y √∫ltima compra
        with col1:
            st.write(f"**Descuento:** {cliente_data['Descuento']}%")
            st.write(f"**√öltima compra:** {cliente_data['Fecha Modificado']}")
    
        # Mostrar vendedor principal
        with col2:
            vendedores = cliente_data['Vendedores'].split(',') if pd.notna(cliente_data['Vendedores']) else ['No asignado']
            vendedor_default = vendedores[0]
            vendedor_seleccionado = st.selectbox("Vendedor", vendedores, index=0)
            st.write(f"**Vendedor Principal:** {vendedor_seleccionado}")
    
        # Secci√≥n de productos solo aparece si hay cliente seleccionado
        st.header("üìÅ Buscador de Productos üîç")
    
        # Tres columnas: Buscador, precio, y stock con colores
        col_prod1, col_prod2, col_prod3 = st.columns([2, 1, 1])
    
        with col_prod1:
            # Buscador de productos con espacio vac√≠o al inicio
            producto_buscado = st.selectbox(
                "Buscar producto",
                [""] + st.session_state.df_productos['Nombre'].unique().tolist(),
                help="Escrib√≠ el nombre del producto o seleccion√° uno de la lista."
            )
    
        if producto_buscado:
            producto_data = st.session_state.df_productos[st.session_state.df_productos['Nombre'] == producto_buscado].iloc[0]
    
            with col_prod2:
                # Mostrar precio
                st.write(f"**Precio:** ${producto_data['Precio']}")
    
            with col_prod3:
                # Mostrar stock con colores seg√∫n la cantidad
                stock = safe_value(producto_data['Stock'], 0)
                if stock <= 0:
                    color = 'red'
                elif stock < 10:
                    color = 'orange'
                else:
                    color = 'green'
    
                st.markdown(f"<span style='color:{color}'>**Stock disponible:** {stock}</span>", unsafe_allow_html=True)
    
            # Dividimos la secci√≥n en dos columnas para mostrar el c√≥digo y la cantidad en la izquierda, y la imagen a la derecha
            col_izq, col_der = st.columns([2, 1])
    
            with col_izq:
                # Mostrar c√≥digo del producto
                st.write(f"**C√≥digo del producto:** {producto_data['Codigo']}")
    
                # Verificar si la venta est√° forzada por m√∫ltiplos
                if pd.notna(producto_data['forzar multiplos']) and producto_data['forzar multiplos'] > 0:
                    st.warning(f"Este producto tiene venta forzada por {int(producto_data['forzar multiplos'])} unidades.")
                    cantidad = st.number_input(
                        "Cantidad",
                        min_value=int(producto_data['forzar multiplos']),
                        step=int(producto_data['forzar multiplos']),
                        key=f"cantidad_{producto_data['Codigo']}"
                    )
                else:
                    # Campo para seleccionar cantidad si no est√° forzada la venta por m√∫ltiplos
                    if stock > 0:
                        cantidad = st.number_input(
                            "Cantidad",
                            min_value=1,
                            max_value=stock,
                            step=1,
                            key=f"cantidad_{producto_data['Codigo']}"
                        )
                    else:
                        cantidad = 0
                        st.error("No hay stock disponible para este producto.")
    
                # Bot√≥n para agregar el producto al pedido, deshabilitado si no hay stock
                boton_agregar_desactivado = stock <= 0  # Deshabilitar el bot√≥n si no hay stock
                if st.button("Agregar producto", disabled=boton_agregar_desactivado, key=f"agregar_{producto_data['Codigo']}"):
                    # Verificar si el producto ya est√° en el pedido
                    existe = any(item['Codigo'] == producto_data['Codigo'] for item in st.session_state.pedido)
                    if existe:
                        st.warning("Este producto ya est√° en el pedido. Por favor, ajusta la cantidad si es necesario.")
                    else:
                        # A√±adir producto al pedido con la cantidad seleccionada
                        producto_agregado = {
                            'Codigo': producto_data['Codigo'],
                            'Nombre': producto_data['Nombre'],
                            'Cantidad': cantidad,
                            'Precio': producto_data['Precio'],
                            'Importe': cantidad * producto_data['Precio']
                        }
                        st.session_state.pedido.append(producto_agregado)
                        # Descontar del stock
                        st.session_state.df_productos.loc[
                            st.session_state.df_productos['Codigo'] == producto_data['Codigo'], 'Stock'
                        ] -= cantidad
                        st.success(f"Se agreg√≥ {cantidad} unidad(es) de {producto_data['Nombre']} al pedido.")
    
            with col_der:
                # Mostrar imagen del producto en la columna aparte
                if pd.notna(producto_data['imagen']) and producto_data['imagen'] != '':
                    try:
                        response = requests.get(producto_data['imagen'], timeout=5)
                        response.raise_for_status()
                        image = Image.open(BytesIO(response.content))
                        st.image(image, width=200, caption="Imagen del producto")
                    except:
                        st.write("üîó **Imagen no disponible o URL inv√°lida.**")
                else:
                    st.write("üîó **No hay imagen disponible.**")
    
        # Mostrar el pedido actual
        if st.session_state.pedido:
            st.header("üì¶ Pedido actual")
    
            # Mostrar la tabla del pedido con la opci√≥n de eliminar √≠tems
            for producto in st.session_state.pedido.copy():  # Use copy to avoid modification during iteration
                codigo = producto['Codigo']
                nombre = producto['Nombre']
                cantidad = producto['Cantidad']
                precio = producto['Precio']
                importe = producto['Importe']
    
                # Crear columnas para mostrar el producto y el bot√≥n de eliminar
                col1, col2, col3, col4, col5, col6 = st.columns([1, 2, 1, 1, 1, 1])
                col1.write(codigo)
                col2.write(nombre)
                col3.write(cantidad)
                col4.write(f"${precio}")
                col5.write(f"${importe}")
    
                # Verificar si este producto est√° pendiente de eliminaci√≥n
                if codigo in st.session_state.delete_confirm:
                    # Mostrar bot√≥n de "S√≠" y "No" en rojo
                    with col6:
                        # Bot√≥n "S√≠" para confirmar eliminaci√≥n
                        if st.button("S√≠", key=f"confirmar_si_{codigo}"):
                            # Eliminar el √≠tem del pedido
                            index = next((i for i, item in enumerate(st.session_state.pedido) if item['Codigo'] == codigo), None)
                            if index is not None:
                                producto_eliminado = st.session_state.pedido.pop(index)
                                # Reponer el stock
                                st.session_state.df_productos.loc[
                                    st.session_state.df_productos['Codigo'] == producto_eliminado['Codigo'], 'Stock'
                                ] += producto_eliminado['Cantidad']
                            # Remover del diccionario de confirmaciones
                            del st.session_state.delete_confirm[codigo]
    
                        # Bot√≥n "No" para cancelar eliminaci√≥n
                        if st.button("No", key=f"confirmar_no_{codigo}"):
                            # Cancelar la eliminaci√≥n
                            del st.session_state.delete_confirm[codigo]
                else:
                    # Mostrar el bot√≥n de eliminar normal
                    with col6:
                        if st.button('üóëÔ∏è', key=f"eliminar_{codigo}"):
                            # Marcar este √≠tem para eliminaci√≥n
                            st.session_state.delete_confirm[codigo] = True
    
            # Calcular totales
            pedido_df = pd.DataFrame(st.session_state.pedido)
            total_items = pedido_df['Cantidad'].sum() if not pedido_df.empty else 0
            total_monto = pedido_df['Importe'].sum() if not pedido_df.empty else 0.0
    
            # Mostrar total de √≠tems y total del pedido en una sola fila
            col_items, col_total = st.columns([1, 1])
    
            with col_items:
                st.write(f"**Total de √≠tems:** {total_items}")
    
            with col_total:
                # Mostrar total del pedido al lado de total de √≠tems
                st.write(f"<h4 style='text-align:right;'>Total del pedido: ${total_monto:,.2f}</h4>", unsafe_allow_html=True)
    
            # Centrar el bot√≥n de guardar pedido
            col_guardar, _ = st.columns([2, 3])
            with col_guardar:
                if st.button("Guardar Pedido"):
                    if not st.session_state.pedido:
                        st.warning("No hay √≠tems en el pedido para guardar.")
                    else:
                        # Obtener fecha y hora actuales
                        argentina = pytz.timezone('America/Argentina/Buenos_Aires')
                        now = datetime.now(argentina)
                        fecha_actual = now.strftime("%Y-%m-%d")
                        hora_actual = now.strftime("%H:%M:%S")
    
                        # Preparar datos del pedido
                        order_data = {
                            'cliente': cliente_seleccionado,
                            'vendedor': vendedor_seleccionado,
                            'fecha': fecha_actual,
                            'hora': hora_actual,
                            'items': st.session_state.pedido
                        }
    
                        # Guardar el pedido en la hoja 'Pedidos'
                        guardar_pedido_excel(file_path_productos, order_data)
    
                        # Confirmar al usuario
                        st.success("Pedido guardado exitosamente.", icon="‚úÖ")
    
                        # Limpiar el pedido despu√©s de guardarlo
                        st.session_state.pedido = []
                        st.session_state.delete_confirm = {}
    
                        # Guardar los cambios en el stock de productos
                        try:
                            with pd.ExcelWriter(file_path_productos, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
                                st.session_state.df_productos.to_excel(writer, sheet_name='Hoja1', index=False)
                        except Exception as e:
                            st.error(f"Error al actualizar el stock en el archivo de productos: {e}")

def modulo_productos():
    # T√≠tulo de la aplicaci√≥n
    st.header("üìÅ Modulo Productos")
    
    # Funci√≥n para convertir DataFrame a Excel en memoria usando openpyxl
    def convertir_a_excel_productos(df, sheet_name='Productos'):
        buffer = BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name=sheet_name)
        excel_bytes = buffer.getvalue()
        return excel_bytes
    
    # Funci√≥n para asegurar que el valor es al menos el m√≠nimo permitido
    def safe_value_productos(value, min_value=0.0):
        try:
            return max(float(value), min_value)
        except:
            return min_value
    
    # Funci√≥n para aplicar color al stock y mostrar el t√≠tulo, cantidad y detalle
    def color_stock_productos(stock):
        try:
            stock = int(stock)
        except:
            stock = 0
        if stock > 10:
            return f'üü¢ Stock\n**{stock} unidades**\n(Suficiente stock)'
        elif stock > 0:
            return f'üü° Stock\n**{stock} unidades**\n(Poco stock)'
        else:
            return f'üî¥ Stock\n**{stock} unidades**\n(Sin stock)'
    
    # Funci√≥n para agregar el footer
    def agregar_footer_productos():
        footer = """
        <style>
        .footer {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            background-color: #f1f1f1;
            color: #555;
            text-align: center;
            padding: 10px 0;
            font-size: 14px;
        }
        </style>
        <div class="footer">
            Powered by VASCO.SORO
        </div>
        """
        st.markdown(footer, unsafe_allow_html=True)
    
    # Sidebar para cargar el archivo Excel
    st.sidebar.header("Cargar Archivo Excel de Productos")
    uploaded_file = st.sidebar.file_uploader("üì§ Subir archivo Excel", type=["xlsx"], key="productos_modulo_productos")
    
    if uploaded_file is not None:
        try:
            # Leer el archivo Excel
            df = pd.read_excel(uploaded_file, engine='openpyxl')
    
            # Mostrar los nombres de las columnas para depuraci√≥n
            st.sidebar.write("üîç **Columnas en el archivo:**")
            st.sidebar.write(df.columns.tolist())
    
            # Inicializaci√≥n de la variable df_modificado
            df_modificado = df.copy()
    
            # Opciones de filtrado y b√∫squeda
            st.sidebar.header("Filtrar Productos")
    
            # Corregir que cada categor√≠a sea individual en el multiselect
            categorias_separadas = set()
            for cat in df['Categorias'].dropna():
                categorias_separadas.update([c.strip() for c in cat.split(',')])  # Separar por coma y agregar al conjunto
    
            filtro_categoria = st.sidebar.multiselect("Selecciona Categor√≠as", options=sorted(categorias_separadas))
    
            # Corregir el filtro de estado activo para que sea S√≠ y No
            filtro_activo = st.sidebar.selectbox("Estado Activo", options=['Todos', 'S√≠', 'No'])
    
            if filtro_categoria:
                pattern = '|'.join([re.escape(cat) for cat in filtro_categoria])
                df = df[df['Categorias'].str.contains(pattern, case=False, na=False)]
    
            if filtro_activo != 'Todos':
                estado_activo = 1 if filtro_activo == 'S√≠' else 0
                df = df[df['Activo'] == estado_activo]
    
            # Configuraci√≥n de la tabla AgGrid
            gb = GridOptionsBuilder.from_dataframe(df)
            gb.configure_pagination(paginationAutoPageSize=True)
            gb.configure_side_bar()
            gb.configure_default_column(
                editable=False,
                groupable=True,
                resizable=False,
                sortable=True,
                wrapText=False,  # Envuelve el texto para columnas largas
                autoHeight=False  # Ajusta la altura autom√°ticamente
            )
    
            # Ajustar el tama√±o de las columnas seg√∫n el contenido
            for column in df.columns:
                gb.configure_column(column, autoWidth=True)
    
            gridOptions = gb.build()
    
            # Mostrar el n√∫mero de art√≠culos filtrados
            st.write(f"Total de Art√≠culos Filtrados: {len(df)}")
    
            # Mostrar la tabla editable con un tema v√°lido y mejor tama√±o de columnas
            mostrar_tabla = st.checkbox("Mostrar Vista Preliminar de la Tabla")
    
            if mostrar_tabla:
                st.header("üìä Tabla de Productos:")
                grid_response = AgGrid(
                    df,
                    gridOptions=gridOptions,
                    data_return_mode=DataReturnMode.FILTERED_AND_SORTED,
                    update_mode=GridUpdateMode.MODEL_CHANGED,
                    fit_columns_on_grid_load=False,
                    theme='streamlit',  # Tema v√°lido
                    enable_enterprise_modules=False,
                    height=500,
                    reload_data=False
                )
    
                # Actualizar df_modificado con la respuesta del grid
                df_modificado = grid_response['data']
    
            # Seleccionar un producto
            st.header("üîç Seleccionar Producto:")
            selected_product = st.selectbox("Selecciona un Producto", [''] + df_modificado['Nombre'].tolist())  # Opci√≥n vac√≠a
    
            if selected_product:
                producto = df_modificado[df_modificado['Nombre'] == selected_product].iloc[0]
    
                # Mostrar los detalles del producto
                st.subheader(f"Detalles de: {selected_product}")
    
                # Organizar los detalles en columnas
                col1, col2 = st.columns([3, 1])
    
                with col1:
                    # Mostrar detalles de forma no editable
                    st.markdown(f"**ID:** {producto['Id']}")
                    st.markdown(f"**C√≥digo:** {producto['Codigo']}")
                    st.markdown(f"**Nombre:** {producto['Nombre']}")
                    st.markdown(f"**Precio:** {producto['Precio']}")
                    st.markdown(f"**Precio x Mayor:** {producto['Precio x Mayor']}")
                    st.markdown(f"**Descripci√≥n:** {producto['Descripcion']}")
                    st.markdown(f"**Categor√≠as:** {producto['Categorias']}")
    
                with col2:
                    st.markdown(f"{color_stock_productos(producto['Stock'])}")
                    # Mostrar la imagen del producto
                    if pd.notnull(producto['imagen']) and producto['imagen'] != '':
                        try:
                            response = requests.get(producto['imagen'], timeout=5)
                            response.raise_for_status()
                            image = Image.open(BytesIO(response.content))
                            st.image(image, width=150)
                        except:
                            st.write("üîó **Imagen no disponible o URL inv√°lida.**")
                    else:
                        st.write("üîó **No hay imagen disponible.**")
                    st.markdown(f"**Costo:** {producto['Costo']}")
                    st.markdown(f"**Costo usd:** {producto['Costo usd']}")
    
                # Opci√≥n para modificar el producto
                modificar = st.checkbox("üîÑ Modificar Producto")
    
                if modificar:
                    st.markdown("---")
                    st.subheader(f"üìù Editar Detalles de: {selected_product}")
    
                    # Checkbox para mostrar campos adicionales
                    mostrar_campos_adicionales = st.checkbox("Agregar Datos de Ubicaci√≥n y Proveedor")
    
                    # Mostrar un formulario con los detalles del producto para editar
                    with st.form(key='editar_producto_unique'):
                        # Organizar los campos en columnas para una mejor est√©tica
                        editar_col1, editar_col2 = st.columns([3, 1])
    
                        with editar_col1:
                            nuevo_nombre = st.text_input("Nombre", value=producto['Nombre'])
                            nuevo_precio = st.number_input(
                                "Precio",
                                min_value=0.0,
                                step=0.01,
                                value=safe_value_productos(float(producto['Precio']), 0.0)
                            )
                            nuevo_precio_x_mayor = st.number_input(
                                "Precio x Mayor",
                                min_value=0.0,
                                step=0.01,
                                value=safe_value_productos(float(producto['Precio x Mayor']), 0.0)
                            )
                            nuevo_costo = st.number_input(
                                "Costo",
                                min_value=0.0,
                                step=0.01,
                                value=safe_value_productos(float(producto['Costo']), 0.0)
                            )
                            nuevo_costo_usd = st.number_input(
                                "Costo usd",
                                min_value=0.0,
                                step=0.01,
                                value=safe_value_productos(float(producto['Costo usd']), 0.0)
                            )
                            nuevo_stock = st.number_input(
                                "Stock",
                                min_value=0,
                                step=1,
                                value=int(safe_value_productos(producto['Stock'], 0))
                            )
                           
                            # Mostrar campos adicionales si se selecciona el checkbox
                            if mostrar_campos_adicionales:
                                nuevo_proveedor = st.text_input("Proveedor", value=producto.get('Proveedor', ''))
                                nuevo_pasillo = st.text_input("Pasillo", value=producto.get('Pasillo', ''))
                                nuevo_estante = st.text_input("Estante", value=producto.get('Estante', ''))
    
                        with editar_col2:
                            nuevo_codigo = st.text_input("Codigo", value=producto['Codigo'])
                            # Mostrar la imagen del producto
                            if pd.notnull(producto['imagen']) and producto['imagen'] != '':
                                try:
                                    response = requests.get(producto['imagen'], timeout=5)
                                    response.raise_for_status()
                                    image = Image.open(BytesIO(response.content))
                                    st.image(image, width=150)
                                except:
                                    st.write("üîó **Imagen no disponible o URL inv√°lida.**")
                            else:
                                st.write("üîó **No hay imagen disponible.**")
                            
                            nuevo_descripcion = st.text_area("Descripci√≥n", value=producto['Descripcion'])
                            nuevo_categorias = st.text_input("Categor√≠as", value=producto['Categorias'])
    
                        submit_edit = st.form_submit_button(label='Guardar Cambios')
    
                        if submit_edit:
                            # Validaciones
                            if not nuevo_nombre:
                                st.error("‚ùå El Nombre no puede estar vac√≠o.")
                            else:
                                # Actualizar el DataFrame original y el modificado
                                df.loc[df['Nombre'] == selected_product, 'Nombre'] = nuevo_nombre
                                df.loc[df['Nombre'] == nuevo_nombre, 'Precio'] = nuevo_precio
                                df.loc[df['Nombre'] == nuevo_nombre, 'Precio x Mayor'] = nuevo_precio_x_mayor
                                df.loc[df['Nombre'] == nuevo_nombre, 'Costo'] = nuevo_costo
                                df.loc[df['Nombre'] == nuevo_nombre, 'Costo usd'] = nuevo_costo_usd
                                df.loc[df['Nombre'] == nuevo_nombre, 'Stock'] = nuevo_stock
                                df.loc[df['Nombre'] == nuevo_nombre, 'Descripcion'] = nuevo_descripcion
                                df.loc[df['Nombre'] == nuevo_nombre, 'Categorias'] = nuevo_categorias
    
                                if mostrar_campos_adicionales:
                                    df.loc[df['Nombre'] == nuevo_nombre, 'Proveedor'] = nuevo_proveedor
                                    df.loc[df['Nombre'] == nuevo_nombre, 'Pasillo'] = nuevo_pasillo
                                    df.loc[df['Nombre'] == nuevo_nombre, 'Estante'] = nuevo_estante
    
                                # Al guardar cambios, se actualiza el DataFrame modificado
                                df_modificado = df.copy()
                                st.success("‚úÖ Producto modificado y archivo actualizado.")
    
            # Funcionalidad para agregar un nuevo producto
            st.header("‚ûï Agregar Nuevo Producto:")
            with st.expander("Agregar Producto"):  # Cambi√© para que sea un expander
                with st.form(key='agregar_producto_unique'):
                    nuevo_id = st.text_input("Id")
                    nuevo_id_externo = st.text_input("Id Externo")
                    nuevo_codigo = st.text_input("C√≥digo")
                    nuevo_nombre = st.text_input("Nombre")
                    nuevo_precio_x_mayor = st.number_input("Precio x Mayor", min_value=0.0, step=0.01)
                    nuevo_activo = st.selectbox("Activo", options=[0, 1])
                    nuevo_fecha_creado = st.date_input("Fecha Creado", value=datetime.now(pytz.timezone('America/Argentina/Buenos_Aires')))
                    nuevo_fecha_modificado = st.date_input("Fecha Modificado", value=datetime.now(pytz.timezone('America/Argentina/Buenos_Aires')))
                    nuevo_descripcion = st.text_area("Descripci√≥n")
                    nuevo_orden = st.number_input("Orden", min_value=0, step=1)
                    nuevo_codigo_barras = st.text_input("C√≥digo de Barras")
                    nuevo_unidad_bulto = st.number_input("Unidad por Bulto", min_value=0, step=1)
                    nuevo_inner = st.text_input("Inner")
                    nuevo_forzar_multiplos = st.text_input("Forzar Multiplos")
                    nuevo_costo_usd = st.number_input("Costo usd", min_value=0.0, step=0.01)
                    nuevo_costo = st.number_input("Costo", min_value=0.0, step=0.01)
                    nuevo_etiquetas = st.text_input("Etiquetas")
                    nuevo_stock = st.number_input("Stock", min_value=0, step=1)
                    nuevo_precio_mayorista = st.number_input("Precio Mayorista", min_value=0.0, step=0.01)
                    nuevo_precio_online = st.number_input("Precio Online", min_value=0.0, step=0.01)
                    nuevo_precio = st.number_input("Precio", min_value=0.0, step=0.01)
                    nuevo_precio_face_dolar = st.number_input("Precio face Dolar", min_value=0.0, step=0.01)
                    nuevo_precio_mayorista_usd = st.number_input("Precio Mayorista USD", min_value=0.0, step=0.01)
                    nuevo_marca = st.text_input("Marca")
                    nuevo_categorias = st.text_input("Categorias")
                    nuevo_imagen = st.text_input("Imagen URL")
                    nuevo_proveedor = st.text_input("Proveedor")
                    nuevo_pasillo = st.text_input("Pasillo")
                    nuevo_estante = st.text_input("Estante")
                    nuevo_fecha_vencimiento = st.date_input("Fecha de Vencimiento", value=datetime.now(pytz.timezone('America/Argentina/Buenos_Aires')))
    
                    submit_nuevo = st.form_submit_button(label='Agregar Producto')
    
                    if submit_nuevo:
                        # Validaciones
                        if not nuevo_id or not nuevo_nombre:
                            st.error("‚ùå Por favor, completa los campos obligatorios (Id y Nombre).")
                        elif df_modificado['Id'].astype(str).str.contains(nuevo_id).any():
                            st.error("‚ùå El Id ya existe. Por favor, utiliza un Id √∫nico.")
                        else:
                            # Agregar el nuevo producto al DataFrame
                            nuevo_producto = {
                                'Id': nuevo_id,
                                'Id Externo': nuevo_id_externo,
                                'Codigo': nuevo_codigo,
                                'Nombre': nuevo_nombre,
                                'Precio x Mayor': nuevo_precio_x_mayor,
                                'Activo': nuevo_activo,
                                'Fecha Creado': nuevo_fecha_creado,
                                'Fecha Modificado': nuevo_fecha_modificado,
                                'Descripcion': nuevo_descripcion,
                                'Orden': nuevo_orden,
                                'Codigo de Barras': nuevo_codigo_barras,
                                'unidad por bulto': nuevo_unidad_bulto,
                                'inner': nuevo_inner,
                                'forzar multiplos': nuevo_forzar_multiplos,
                                'Costo usd': nuevo_costo_usd,
                                'Costo': nuevo_costo,
                                'Etiquetas': nuevo_etiquetas,
                                'Stock': nuevo_stock,
                                'Precio Mayorista': nuevo_precio_mayorista,
                                'Precio Online': nuevo_precio_online,
                                'Precio': nuevo_precio,
                                'Precio face Dolar': nuevo_precio_face_dolar,
                                'Precio Mayorista USD': nuevo_precio_mayorista_usd,
                                'Marca': nuevo_marca,
                                'Categorias': nuevo_categorias,
                                'imagen': nuevo_imagen,
                                'Proveedor': nuevo_proveedor,
                                'Pasillo': nuevo_pasillo,
                                'Estante': nuevo_estante,
                                'Fecha de Vencimiento': nuevo_fecha_vencimiento
                            }
                            df_modificado = df_modificado.append(nuevo_producto, ignore_index=True)
                            st.success("‚úÖ Producto agregado exitosamente.")
    
            # Bot√≥n para descargar el archivo Excel modificado al final de todo
            st.header("üíæ Descargar Archivo Modificado:")
            excel = convertir_a_excel_productos(df_modificado, sheet_name='Productos')
    
            # Obtener la fecha y hora actual en horario de Argentina
            argentina = pytz.timezone('America/Argentina/Buenos_Aires')
            timestamp = datetime.now(argentina).strftime("%Y%m%d_%H%M%S")
    
            # Crear el nombre del archivo con el timestamp
            file_name = f"productos_modificados_{timestamp}.xlsx"
    
            st.download_button(
                label="üì• Descargar Excel Modificado",
                data=excel,
                file_name=file_name,
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
    
        except Exception as e:
            st.error(f"‚ùå Ocurri√≥ un error al procesar el archivo: {e}")
    else:
        st.info("üìÇ Por favor, sube un archivo Excel para comenzar.")

def modulo_convertidor_csv():
    # T√≠tulo de la aplicaci√≥n
    st.header("üìÅ Convertidor de CSV a Excel")
    
    # Funci√≥n para limpiar y convertir las columnas 'Id' y 'Id Cliente' eliminando solo puntos
    def limpiar_id(valor):
        if pd.isnull(valor):
            return ""
        # Eliminar solo puntos
        valor_limpio = str(valor).replace('.', '')
        return valor_limpio
    
    # Funci√≥n para convertir DataFrame a Excel en memoria usando openpyxl
    def convertir_a_excel_csv(df, sheet_name='Hoja1'):
        buffer = BytesIO()
        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name=sheet_name)
        excel_bytes = buffer.getvalue()
        return excel_bytes
    
    # Funci√≥n general para procesar archivos
    def procesar_archivo(
        uploaded_file,
        tipo,
        columnas_a_renombrar,
        columnas_a_eliminar,
        columnas_a_agregar,
        columnas_id
    ):
        if uploaded_file is not None:
            try:
                # Leer el archivo CSV con separador ';' y codificaci√≥n 'ISO-8859-1'
                df = pd.read_csv(
                    uploaded_file,
                    encoding='ISO-8859-1',
                    sep=';',
                    on_bad_lines='skip',
                    dtype=str  # Leer todas las columnas como cadenas para evitar problemas de tipo
                )
    
                # Limpiar nombres de columnas (eliminar espacios al inicio y final)
                df.columns = df.columns.str.strip()
    
                # Mostrar los nombres de las columnas para depuraci√≥n
                st.write(f"üîç **Columnas encontradas en {tipo}:**")
                st.write(df.columns.tolist())
    
                # Verificar y limpiar las columnas de identificaci√≥n
                for columna in columnas_id:
                    if columna in df.columns:
                        df[columna] = df[columna].apply(limpiar_id)
                        st.write(f"‚úÖ **Columna '{columna}' limpiada correctamente.**")
                    else:
                        st.warning(f"‚ö†Ô∏è La columna '{columna}' no se encuentra en el archivo de {tipo}.")
    
                # Renombrar las columnas especificadas, manejando variaciones en el nombre
                if columnas_a_renombrar:
                    columnas_a_renombrar_final = {}
                    for original, nuevo in columnas_a_renombrar.items():
                        # Crear un patr√≥n regex para manejar may√∫sculas/min√∫sculas
                        pattern = re.compile(re.escape(original), re.IGNORECASE)
                        matches = [col for col in df.columns if pattern.fullmatch(col)]
                        for match in matches:
                            columnas_a_renombrar_final[match] = nuevo
                    if columnas_a_renombrar_final:
                        df = df.rename(columns=columnas_a_renombrar_final)
                        st.write(f"üîÑ **Renombrando columnas en {tipo}:**")
                        st.write(columnas_a_renombrar_final)
                    else:
                        st.warning(f"‚ö†Ô∏è No se encontraron columnas para renombrar en {tipo}.")
    
                # Eliminar columnas que no sirven
                if columnas_a_eliminar:
                    columnas_existentes_a_eliminar = [col for col in columnas_a_eliminar if col in df.columns]
                    if columnas_existentes_a_eliminar:
                        df = df.drop(columns=columnas_existentes_a_eliminar, errors='ignore')
                        st.write(f"üóëÔ∏è **Eliminando columnas en {tipo}:** {columnas_existentes_a_eliminar}")
                    else:
                        st.warning(f"‚ö†Ô∏è No se encontraron columnas para eliminar en {tipo}.")
    
                # Agregar nuevas columnas vac√≠as si no existen
                if columnas_a_agregar:
                    nuevas_agregadas = []
                    for columna in columnas_a_agregar:
                        if columna not in df.columns:
                            df[columna] = ''
                            nuevas_agregadas.append(columna)
                    if nuevas_agregadas:
                        st.write(f"‚ûï **Nuevas columnas agregadas en {tipo}:** {nuevas_agregadas}")
    
                # Convertir las columnas de identificaci√≥n a cadenas para evitar comas en la visualizaci√≥n
                for columna in columnas_id:
                    if columna in df.columns:
                        df[columna] = df[columna].astype(str)
    
                # Mostrar una tabla de datos modificada en la interfaz de Streamlit
                st.write(f"üìä **Archivo de {tipo} modificado:**")
                st.dataframe(df)
    
                # Convertir el DataFrame a Excel en memoria
                excel = convertir_a_excel_csv(df, sheet_name='Hoja1')
    
                # Obtener la fecha y hora actual en horario de Argentina
                argentina = pytz.timezone('America/Argentina/Buenos_Aires')
                timestamp = datetime.now(argentina).strftime("%Y%m%d_%H%M%S")
    
                # Crear el nombre del archivo con el timestamp
                file_name = f"{tipo}_modificado_{timestamp}.xlsx"
    
                # Bot√≥n para descargar el archivo Excel modificado
                st.download_button(
                    label=f"üì• Descargar {tipo} Modificado",
                    data=excel,
                    file_name=file_name,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
    
            except Exception as e:
                st.error(f"‚ùå Ocurri√≥ un error al procesar el archivo: {e}")
        else:
            st.info(f"üìÇ Por favor, sube un archivo CSV de {tipo} para comenzar.")

    # Interfaz para cargar archivos de clientes
    st.sidebar.header("Cargar Archivo CSV de Clientes")
    uploaded_clientes_file = st.sidebar.file_uploader("üì§ Subir archivo CSV de Clientes", type=["csv"], key="clientes_modulo_csv")

    # Definir par√°metros espec√≠ficos para los clientes
    columnas_renombrar_clientes = {
        'Id Cliente': 'Id',
        'Nombre Cliente': 'Nombre'
    }
    columnas_eliminar_clientes = ['Tel√©fono', 'Direcci√≥n', 'Observaciones']
    columnas_agregar_clientes = ['Fecha Modificado', 'Descuento', 'Vendedores']
    columnas_id_clientes = ['Id Cliente']

    # Procesar archivo de clientes
    procesar_archivo(
        uploaded_clientes_file,
        'clientes',
        columnas_renombrar_clientes,
        columnas_eliminar_clientes,
        columnas_agregar_clientes,
        columnas_id_clientes
    )

    # Interfaz para cargar archivos de productos
    st.sidebar.header("Cargar Archivo CSV de Productos")
    uploaded_productos_file = st.sidebar.file_uploader("üì§ Subir archivo CSV de Productos", type=["csv"], key="productos_modulo_csv")

    # Definir par√°metros espec√≠ficos para los productos
    columnas_renombrar_productos = {
        'Id Producto': 'Id',
        'Descripci√≥n': 'Nombre'
    }
    columnas_eliminar_productos = ['Unidad Medida', 'Proveedor', 'Descuento']
    columnas_agregar_productos = ['Fecha Creado', 'Activo', 'Precio', 'Stock', 'Categorias']
    columnas_id_productos = ['Id Producto']

    # Procesar archivo de productos
    procesar_archivo(
        uploaded_productos_file,
        'productos',
        columnas_renombrar_productos,
        columnas_eliminar_productos,
        columnas_agregar_productos,
        columnas_id_productos
    )
